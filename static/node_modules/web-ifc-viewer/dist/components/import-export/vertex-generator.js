import { BoxGeometry, Color, LineBasicMaterial, LineSegments, Mesh, MeshBasicMaterial, Vector2, Vector3 } from 'three';
export class VertexGenerator {
    constructor(context, clipper) {
        this.context = context;
        this.clipper = clipper;
        this.minimumOffset = 0.1;
        this.buckets = [];
        this.bucketsOffset = new Vector3();
        this.polygons = [];
        this.currentBucketIndex = 0;
        this.dims = { pixels: new Vector2(), real: new Vector2() };
        this.htmlImage = document.createElement('img');
        this.htmlImage.onload = () => this.getEdges2DPoints();
    }
    initializeOpenCV(openCV) {
        this.cv = openCV;
    }
    async getVertices(bucketWidth) {
        this.getDimensions(bucketWidth);
        const { size, center } = this.getSizeAndCenter();
        const xBucketsCount = Math.ceil(size.x / this.dims.real.x);
        const zBucketsCount = Math.ceil(size.z / this.dims.real.y);
        const scene = this.context.getScene();
        const box = new BoxGeometry(this.dims.real.x, 1, this.dims.real.y);
        const colorFraction = 1 / (xBucketsCount * zBucketsCount);
        let currentColor = 0;
        this.bucketsOffset.copy(center);
        this.bucketsOffset.x += -size.x / 2 - this.minimumOffset;
        this.bucketsOffset.z += size.z / 2 + this.minimumOffset;
        // const temp = new Mesh(new BoxGeometry(0.1, 4, 0.1), new MeshBasicMaterial({ color: 0xff0000 }));
        // temp.position.copy(this.bucketsOffset);
        // temp.position.y = 0;
        // scene.add(temp);
        // Generate all buckets
        for (let i = 0; i < xBucketsCount; i++) {
            currentColor += colorFraction;
            for (let j = 0; j < zBucketsCount; j++) {
                const xPosition = i * this.dims.real.x;
                const zPosition = j * this.dims.real.y;
                const material = new MeshBasicMaterial({
                    color: new Color(currentColor, currentColor, currentColor),
                    transparent: true,
                    opacity: 0.2
                });
                currentColor += colorFraction;
                const mesh = new Mesh(box, material);
                mesh.visible = false;
                scene.add(mesh);
                this.buckets.push({ mesh, row: i, column: j });
                mesh.position.copy(center);
                mesh.position.x += -size.x / 2 + this.dims.real.x / 2 + xPosition - this.minimumOffset;
                mesh.position.z += size.z / 2 - this.dims.real.y / 2 - zPosition + this.minimumOffset;
            }
        }
        // Make all lines thin
        const basicLineMat = new LineBasicMaterial({ color: 0x000000 });
        const tempLines = [];
        const previousLines = [];
        this.clipper.planes.forEach((plane) => {
            Object.values(plane.edges.edges).forEach((edges) => {
                const line = new LineSegments(edges.generatorGeometry, basicLineMat);
                scene.add(line);
                edges.mesh.visible = false;
                tempLines.push(line);
                previousLines.push(edges.mesh);
            });
        });
        console.log(this.buckets.length);
        await this.renderBucket();
    }
    getModel() {
        const model = this.context.items.ifcModels[0];
        if (!model.geometry)
            throw new Error('No model was found for vertex processing!');
        if (!model.geometry.boundingBox) {
            model.geometry.computeBoundingBox();
        }
        return model;
    }
    getDimensions(bucketWidth) {
        this.dims.pixels = this.context.getDimensions();
        this.dims.real.x = bucketWidth;
        this.dims.real.y = (bucketWidth * this.dims.pixels.y) / this.dims.pixels.x;
        this.htmlImage.width = this.dims.pixels.x;
        this.htmlImage.height = this.dims.pixels.y;
    }
    getSizeAndCenter() {
        const model = this.getModel();
        const size = new Vector3();
        const center = new Vector3();
        model.geometry.boundingBox.getSize(size);
        model.geometry.boundingBox.getCenter(center);
        return { size, center };
    }
    async renderBucket() {
        const bucket = this.buckets[this.currentBucketIndex];
        const controls = this.context.ifcCamera.cameraControls;
        await controls.fitToBox(bucket.mesh, false);
        controls.update(0);
        this.htmlImage.src = this.context.renderer.newScreenshot();
    }
    async getEdges2DPoints() {
        const src = this.cv.imread(this.htmlImage);
        // https://docs.opencv.org/3.4/dc/dcf/tutorial_js_contour_features.html
        this.cv.cvtColor(src, src, this.cv.COLOR_RGBA2GRAY, 0);
        // this.cv.threshold(src, src, 100, 200, this.cv.THRESH_BINARY);
        this.cv.bitwise_not(src, src);
        const contours = new this.cv.MatVector();
        const hierarchy = new this.cv.Mat();
        const poly = new this.cv.MatVector();
        this.cv.findContours(src, contours, hierarchy, this.cv.RETR_CCOMP, this.cv.CHAIN_APPROX_SIMPLE);
        // approximates each contour to polygon
        for (let i = 0; i < contours.size(); ++i) {
            const tmp = new this.cv.Mat();
            const cnt = contours.get(i);
            // You can try more different parameters
            this.cv.approxPolyDP(cnt, tmp, 1, true);
            // console.log(tmp.data32S);
            poly.push_back(tmp);
            cnt.delete();
            tmp.delete();
        }
        // Get all polygons
        const bucket = this.buckets[this.currentBucketIndex];
        const size = poly.size();
        for (let i = 0; i < size; i++) {
            const polygon = Array.from(poly.get(i).data32S);
            // Add offset and convert from pixel to real units
            for (let j = 0; j < polygon.length; j++) {
                if (j === 0 || j % 2 === 0) {
                    // x axis
                    // Translate pixels to real units
                    polygon[j] = (polygon[j] * this.dims.real.x) / this.dims.pixels.x;
                    polygon[j] = this.bucketsOffset.x + polygon[j] + this.dims.real.x * bucket.row;
                }
                else {
                    // z axis
                    // Translate pixels to real units
                    polygon[j] = (polygon[j] * this.dims.real.y) / this.dims.pixels.y;
                    const flippedCoord = -(polygon[j] - this.dims.real.y);
                    polygon[j] = -this.bucketsOffset.z + flippedCoord + this.dims.real.y * bucket.column;
                }
            }
            this.polygons.push(polygon);
        }
        this.currentBucketIndex++;
        if (this.currentBucketIndex < this.buckets.length) {
            await this.renderBucket();
        }
        else {
            console.log(this.polygons);
        }
    }
}
//# sourceMappingURL=vertex-generator.js.map